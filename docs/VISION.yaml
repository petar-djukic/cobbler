id: vision-cobbler
title: Cobbler Vision

executive_summary: |
  Cobbler cobbles together context for coding agents. We break work into small tasks,
  assemble the right context for each task, and dispatch to agents one-shot. Over repeated
  cycles, this becomes an iterative method for managing what agents see and do. We are not a
  coding agent, planning agent, or IDE plugin. We are a CLI tool that turns a
  specification-driven codebase into a software factory.

problem: |
  Software development with AI agents is inductive. Two problems compound as projects grow.

  Path matters. Asking an agent to "implement feature X" produces different results depending
  on what code already exists, what the agent sees, and what sequence of changes it makes.
  Small decisions compound into tangled architectures. Developers cannot control the path an
  agent takes through a codebase.

  Context compounds. An agent needs enough context to produce correct code, but showing it
  everything is wasteful and expensive. As projects grow, assembling the right context for
  each task becomes the bottleneck. Developers resort to manual copy-paste or feed entire
  repositories, burning tokens on irrelevant files.

  Existing solutions approach this piecemeal. Some tools wrap agents in script loops but
  ignore git isolation. Others manage branches but lack task proposal intelligence. None
  combine project analysis, task decomposition, isolated execution, and automated merging
  into a single workflow driven by project specifications.

what_this_does: |
  We solve this with five commands named after shoemaking terms, reflecting the craft of
  assembling pieces into a whole.

  Measure reads the project state (documentation, architecture, existing issues, source code)
  and invokes an agent to propose tasks. Each invocation proposes one task. We run this
  iteratively N times, where each call sees previously created issues for dependency awareness.
  Proposed tasks are imported into the cupboard issue tracker with dependency wiring.

  Stitch executes ready tasks. For each task, we create a git worktree on a dedicated task
  branch, build a prompt from the task description and full project context, invoke the agent
  in a podman container, commit the agent's changes (the orchestrator manages all git
  operations; the agent is forbidden from running git), merge the task branch back, record
  metrics, and close the task.

  Inspect evaluates output quality. It analyzes completed work against PRD requirements,
  checks test coverage, measures code quality metrics, and identifies issues that need
  attention.

  Mend fixes problems found by inspect. It runs targeted repairs (test fixes, lint fixes,
  documentation corrections) without full task decomposition.

  Pattern proposes design changes. It analyzes the codebase for architectural patterns,
  suggests refactoring opportunities, and creates design proposals grounded in existing
  specifications.

  The generation lifecycle wraps multiple measure-stitch cycles. A generation starts by
  tagging the current main state, creating a generation branch, and preparing a clean
  workspace. Cycles build up the codebase on the generation branch. When complete, we merge
  back to main, tag the result, and clean up. Interrupted generations can be resumed with
  automatic recovery of stale tasks.

why_we_build_this: |
  We build this because AI-assisted development at scale requires tooling that understands the
  development lifecycle, not just the editor. Cobbler sits at the intersection of build
  automation, version control (git), issue tracking (cupboard), and AI execution (Claude Code
  in podman containers), connecting them into a repeatable, config-driven workflow.

  Cobbler-scaffold validates this approach. Three releases, 16 use cases, and 105 test cases
  prove that the measure-stitch workflow produces working code from specifications. Scaffold
  benchmarks show that iterative measure (one issue per Claude call) scales linearly, while
  batch proposals time out at three or more issues. Full context injection (a single YAML blob
  of all project documents) reduces Claude turns from ~51 to 2-4.

  These findings define cobbler's execution model: full context injection replaces selective
  assembly, iterative measure replaces batch proposals, Claude Code CLI in podman replaces
  planned SDK integration, and history artifacts replace planned OpenTelemetry tracing.

related_projects:
  - project: Crumbs
    role: Provides the cupboard issue tracker and storage library that cobbler uses for task management
  - project: Cobbler-scaffold
    role: Build automation library that validates the cobbler workflow; three releases, 16 use cases, 105 test cases
  - project: Claude Code
    role: AI coding agent invoked inside podman containers for measure and stitch phases

success_criteria:
  automation_efficiency: |
    A single cobbler command produces working code from specifications. The number of cycles,
    task limits, and all other options live in configuration, making every generation
    reproducible. Each cycle proposes tasks aligned with the roadmap and executes them without
    human intervention. Recovery from interrupted runs restores state and continues without
    data loss. Generation efficiency is tracked per invocation: cost (USD), tokens
    (input/output/cache_create/cache_read), wall-clock time, and LOC delta.
  code_quality: |
    Generated code conforms to project PRDs and architecture. Commits reference the tasks and
    PRDs they implement. The inspect command evaluates output against requirements, test
    coverage, and code quality metrics. Quality gates (tests, lint, build) validate every
    stitch task before merge.
  developer_experience: |
    Projects integrate cobbler through a YAML configuration file. All workflow options are
    config-driven; RunMeasure and RunStitch take no parameters. Prompt templates are embedded
    with config-based override. The developer's interaction surface is five CLI commands, not
    cobbler internals.

implementation_phases:
  - phase: "01.0"
    focus: Core measure and stitch
    deliverables: Full context injection, container-isolated Claude, generation lifecycle, iterative measure, history artifacts, config-driven orchestration, orchestrator-managed git
  - phase: "02.0"
    focus: Stitch for code
    deliverables: Git worktree isolation for code tasks, task branch naming, quality gates before merge
  - phase: "03.0"
    focus: Inspect, mend, and pattern
    deliverables: Quality evaluation in inspect, automated fixes in mend, design proposals in pattern
  - phase: "99.0"
    focus: Unscheduled
    deliverables: Agent interface strategy pattern (prd003), OpenTelemetry tracing (prd004 future), recursive operations, parallel execution

risks:
  - risk: Claude produces invalid code that fails to compile
    impact: Stitch task fails, blocking generation progress
    likelihood: Medium
    mitigation: Recovery mechanism resets failed tasks to ready; next cycle retries with updated context
  - risk: Git merge conflicts between task branches
    impact: Task merge fails, requiring manual intervention
    likelihood: Low
    mitigation: Worktree isolation limits conflict surface; tasks are small and focused
  - risk: Cupboard state corruption from interrupted runs
    impact: Task state lost, orphaned in-progress issues
    likelihood: Low
    mitigation: Resume scans for stale task branches and resets orphaned issues to ready
  - risk: Claude invocation costs exceed budget
    impact: Generation becomes prohibitively expensive
    likelihood: Medium
    mitigation: Per-invocation cost tracking, configurable task limits, prompt caching reduces marginal cost

not:
  - We are not building a coding agent. Claude is a black box that receives a prompt and produces code. We do not define agent capabilities, tool use policies, or multi-agent communication.
  - We are not building a planning agent. Measure proposes tasks but does not reason about architecture or make design decisions beyond what specifications prescribe.
  - We are not building a task tracker. We use cupboard (crumbs) for task state. Cobbler reads and writes tasks but does not provide dashboards or project management.
  - We are not building an IDE plugin. Cobbler is a CLI tool. IDE integration is out of scope.
  - We are not building a CI/CD pipeline. Cobbler runs locally on developer machines.
  - We are not building a recursive system (yet). Each measure-stitch cycle is one level deep. Recursive decomposition is unscheduled.
  - We are not building a workflow engine. Cobbler has five fixed commands, not configurable pipelines.
  - We are not building an LLM wrapper or SDK integration. We invoke Claude Code CLI through podman containers.
