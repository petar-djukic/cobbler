id: vision
title: Cobbler Vision

executive_summary: |
  Cobbler cobbles together context for coding agents. We break work into small
  tasks, assemble the right context for each one, and dispatch to an agent
  one-shot. The agent executes without back-and-forth; cobbler evaluates the
  result and decides what happens next. Over repeated cycles, cobbler becomes
  an iterative method for managing what coding agents see and do.

  Coding agents are guided components. They produce useful output, but quality
  depends on the context they receive. Cobbler tests whether iterative context
  management — breaking work down, assembling the right inputs, evaluating
  outputs, and refining the process — can compose guided agents into something
  more reliable than running them ad hoc. We are not a coding agent, a task
  tracker, or a CI system. We operate agents; we do not replace them.

problem: |
  Software development with coding agents is inductive. Given step n (the
  current codebase), the agent produces step n+1 (a small addition or change).
  Each step layers code on existing code, starting from zero. This works when
  steps are small and well-defined. Give an agent a clear function to write or
  a specific bug to fix and it performs.

  Two things go wrong. First, the path through the induction matters. A sequence
  of steps that produces tangled code makes the next step harder. Eventually the
  codebase becomes so knotted that the agent cannot make progress — a refactor
  is needed, and the refactor may itself be too large for a single step. The
  path can become unproductive.

  Second, context compounds. Each step adds code, and the agent needs to
  understand some of it to take the next step. But giving the agent everything
  is wasteful: more tokens, more noise, worse focus. We want to give the agent
  the least context it needs to do the job. This is the context management
  problem.

  Manual operation does not solve either problem at scale. A human reads the
  project state, formulates a prompt, invokes the agent, reviews output, and
  uses a gut feeling to decide what to do next. Prototype bash scripts
  (make-work.sh and do-work.sh) automated parts of this loop but reached their
  limits: they lack direct access to work item storage, build prompts through
  string concatenation, and have no structured evaluation of results.

what_this_does: |
  Cobbler replaces those prototypes. We import the crumbs Go module and call
  cupboard methods directly: Cupboard.GetTable("crumbs").Get(id),
  Cupboard.GetTable("crumbs").Set(id, data). We use structured prompt templates
  rather than string concatenation. We implement commands that cover the full
  inductive cycle: assess state, assemble minimal context, execute a step,
  evaluate the result, fix issues, and propose design changes.

  Each cycle is a step in the induction. Cobbler manages the path by choosing
  what work to do next and in what order. It manages context by assembling only
  what the agent needs for that step. When the path goes wrong — code tangles,
  a refactor looms — cobbler can break the refactor into steps the agent can
  handle.

  Five commands, named after shoemaking terms, cover this cycle: measure
  (assess project state, propose tasks), stitch (execute work via AI agents),
  inspect (evaluate output quality), mend (fix issues found by inspect), and
  pattern (propose design and structural changes).

  A human invokes cobbler and walks away. Cobbler breaks the work down,
  dispatches agents, evaluates results, and reports back when something needs
  a decision. The human does not approve each step; cobbler handles the loop
  and surfaces only what requires judgment.

  The five operations are themselves stored as crumbs. Initially the operations
  are fixed: measure always reads project state the same way, stitch always
  builds prompts the same way. But because operation definitions live in the
  cupboard, they can change. Templates make context strategies swappable.
  Different templates can assemble different slices of context for the same
  task, letting us experiment with what the agent actually needs. Crumbs trails
  record the path through the induction — what steps were taken, in what order,
  with what context — so we can compare strategies and learn which paths
  produce clean code and which produce tangles.

why_we_build_this: |
  Cobbler uses crumbs as its work store. The cupboard holds both cobbler's own
  work (planning, evaluation, design proposals) and work intended for agents
  (documentation, code). A property on each crumb indicates its type: planning,
  documentation, coding, or operations. Cobbler reads work from the cupboard,
  formulates prompts, dispatches agents, updates state, and creates new work
  items as it discovers them.

  We leverage the existing cupboard interfaces defined in crumbs. The Cupboard
  interface has GetTable(name) returning a table reference, and each table has
  Get and Set methods. The attach/detach methods connect to backends with
  optional JSON configuration. Cobbler calls these interfaces rather than
  shelling out to bd commands.

related_projects:
  - project: Crumbs
    role: Work item storage (cupboard); accessed via Go module import
  - project: Beads (bd)
    role: CLI for crumbs; cobbler replaces bd usage with direct Go calls
  - project: make-work.sh
    role: Prototype work creation; cobbler measure replaces this script
  - project: do-work.sh
    role: Prototype work execution; cobbler stitch replaces this script
  - project: Claude Code
    role: AI agent runtime; cobbler invokes agents but does not replace the runtime

success_criteria:
  task_completion: |
    Agents complete documentation and code tasks via cobbler stitch without
    back-and-forth. The human invokes cobbler; cobbler handles the rest and
    reports back.
  cupboard_integration: |
    Cobbler accesses crumbs directly through Go module import, never through
    shell commands to bd.
  replaced_prototypes: |
    make-work.sh functionality moves to cobbler measure; do-work.sh
    functionality moves to cobbler stitch. The scripts become obsolete.

implementation_phases:
  - phase: "01.0"
    focus: Stitch for documentation
    deliverables: |
      cobbler stitch executes documentation tasks; cupboard read/write via
      crumbs module; prompt templates for doc work
  - phase: "02.0"
    focus: Stitch for code
    deliverables: |
      cobbler stitch executes code tasks; git worktree management; test
      execution hooks
  - phase: "03.0"
    focus: Measure
    deliverables: |
      cobbler measure assesses project state and proposes tasks; replaces
      make-work.sh
  - phase: "04.0"
    focus: Inspect, mend, pattern
    deliverables: |
      cobbler inspect evaluates output; cobbler mend fixes issues; cobbler
      pattern proposes design changes

risks:
  - risk: Crumbs module API changes
    impact: High
    likelihood: Medium
    mitigation: Pin crumbs version; update cobbler when crumbs releases
  - risk: Agent output quality varies
    impact: Medium
    likelihood: High
    mitigation: Inspect and mend commands provide feedback loop; human approval gates
  - risk: Path produces tangled code
    impact: High
    likelihood: Medium
    mitigation: Pattern detects structural problems early; cobbler breaks large refactors into agent-sized steps
  - risk: Prompt template complexity
    impact: Medium
    likelihood: Medium
    mitigation: Start with simple templates; iterate based on agent performance
  - risk: Git worktree edge cases
    impact: Low
    likelihood: Medium
    mitigation: Test worktree lifecycle thoroughly; graceful cleanup on failure

not:
  - We are not a coding agent. Agents code; cobbler dispatches them.
  - We are not a planning agent. Agents plan; cobbler decomposes work and hands it off.
  - We are not a task tracker. Crumbs stores the work; cobbler reads, writes, and creates work items but does not replace crumbs.
  - We are not an IDE plugin. Cobbler runs from the terminal.
  - We are not a CI system. We do not run on push, trigger builds, or gate merges.
  - We are not a recursive system yet. Cobbler is guided; a human sets direction and cobbler executes.
  - We are not a workflow engine. We do not define DAGs, manage dependencies between jobs, or manage multi-service deployments.
  - We are not an LLM wrapper or prompt library. We call AI agents through their existing interfaces.
