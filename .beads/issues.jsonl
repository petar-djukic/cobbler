{"id":"cobbler-3lw","title":"Create benchmark fixture: Hello World","description":"## Required Reading\n- docs/VISION.md § What Cobbler Does (one-shot dispatch, context assembly)\n- docs/ARCHITECTURE.md § Lifecycle, § Stitch Workflow\n- docs/use-cases/rel01.0-uc004-benchmark-hello-world.md (use case this fixture validates)\n\n## Files to Create/Modify\n- benchmarks/hello-world/VISION.md (create) - Minimal spec: a Go CLI that prints Hello, World!\n- benchmarks/hello-world/benchmark.yaml (create) - Metadata: name, expected files, pass criteria\n- benchmarks/hello-world/expected/main.go (create) - Reference implementation\n- benchmarks/hello-world/expected/go.mod (create) - Reference module file\n\n## Requirements\n- VISION.md describes a trivial Go CLI: one main.go, prints Hello, World! to stdout, exits 0\n- benchmark.yaml specifies: name, description, language (Go), expected output files, pass criteria (go build succeeds, binary output matches expected string)\n- expected/ directory contains the reference implementation for comparison\n- The fixture must work standalone: an agent given only the VISION.md should produce equivalent code\n\n## Design Decisions\n- Keep the fixture minimal: one spec doc, one expected output file\n- benchmark.yaml uses a simple schema: name, language, files, criteria (extensible later)\n- No ARCHITECTURE.md in the fixture; hello world needs no architecture\n\n## Acceptance Criteria\n- [ ] benchmarks/hello-world/ directory exists with VISION.md, benchmark.yaml, expected/\n- [ ] VISION.md is a complete spec an agent could work from\n- [ ] benchmark.yaml is valid YAML with name, expected files, and pass criteria\n- [ ] expected/main.go builds and prints Hello, World!","status":"open","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:24:40.038582-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:24:40.038582-05:00","labels":["code"]}
{"id":"cobbler-9c9","title":"Cupboard connection wrapper","description":"## Required Reading\n- docs/ARCHITECTURE.md § Cupboard Integration, § Main Interfaces\n- docs/road-map.yaml (rel01.0-uc001-cupboard-connection)\n- /Users/petardjukic/WORKSPACE/crumbs/pkg/types/cupboard.go (Cupboard interface)\n- /Users/petardjukic/WORKSPACE/crumbs/pkg/types/table.go (Table interface)\n- /Users/petardjukic/WORKSPACE/crumbs/pkg/types/config.go (Config type)\n- /Users/petardjukic/WORKSPACE/crumbs/internal/sqlite/backend.go (NewBackend factory)\n\n## Files to Create/Modify\n- internal/crumbs/cupboard.go (create) - Wrapper that initializes cupboard, exposes typed accessors\n- internal/crumbs/cupboard_test.go (create) - Integration tests against crumbs SQLite backend\n\n## Requirements\n- NewCupboard(dataDir string) function that creates sqlite.NewBackend(), calls Attach with SQLite config\n- Close() method that calls Detach()\n- GetCrumb(id string) method that calls GetTable(crumbs).Get(id) and returns typed Crumb\n- SetCrumb(id string, crumb) method that calls GetTable(crumbs).Set(id, data)\n- FetchCrumbs(filter) method that calls GetTable(crumbs).Fetch(filter)\n- Error wrapping: wrap crumbs errors with cobbler context\n\n## Design Decisions\n- Thin wrapper: do not re-abstract the Cupboard interface, just provide typed convenience methods\n- Data dir defaults to .crumbs in the project root (matches crumbs convention)\n- Integration tests use a temp directory for SQLite storage\n- Keep the wrapper in internal/crumbs (not pkg/) per Go layout rule\n\n## Acceptance Criteria\n- [ ] NewCupboard creates and attaches a working SQLite backend\n- [ ] GetCrumb retrieves a crumb by ID and returns typed result\n- [ ] SetCrumb creates and updates crumbs\n- [ ] FetchCrumbs returns filtered results\n- [ ] Close detaches cleanly\n- [ ] Integration tests pass with real SQLite backend\n- [ ] Maps to rel01.0-uc001-cupboard-connection","status":"open","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:25:04.626494-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:25:04.626494-05:00","labels":["code"]}
{"id":"cobbler-mq5","title":"Cobbler Bootstrap","description":"Bootstrap cobbler project with documentation: VISION.md, ARCHITECTURE.md, and ROADMAP.yaml. Cobbler is a partial recursive component and a testbed for creating recursive behavior from guided coding agents. Coding agents are guided components - they can run unguided but results may not be good. Cobbler tests whether work breakdown, dispatch, and self-reflection can compose guided agents into a system that approaches recursive behavior. Four self-* capabilities: self-orienting (measure), self-programming (stitch), self-reflection (inspect/mend), self-architecting (pattern). Agents are plug-and-play. Replaces prototype scripts (make-work.sh, do-work.sh).","status":"open","priority":2,"issue_type":"epic","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:45:47.509775-05:00","created_by":"petardjukic","updated_at":"2026-02-05T22:35:51.02032-05:00"}
{"id":"cobbler-mq5.1","title":"Write VISION.md","description":"## Required Reading\n- .claude/rules/vision-format.md (format rule)\n- .claude/rules/documentation-standards.md (writing style)\n- .claude/rules/promt.md (Cupboard/Table design brief)\n- Bootstrap description in .claude/commands/bootstrap.md\n\n## Files to Create\n- docs/VISION.md\n\n## Requirements\n\nWrite VISION.md per vision-format rule.\n\nCobbler is a partial recursive component and a testbed for creating recursive behavior from guided coding agents. It applies the autogenic systems pattern to software development.\n\nCoding agents (Claude, etc.) are guided components. They have self-programming capabilities - they can generate code and docs - but they work best with human oversight. They can run unguided, but the results may not be good. Left to work on a large task, a coding agent wastes tokens on orientation, iterates through misunderstandings, and produces inconsistent results.\n\nCobbler tests whether you can compose guided coding agents into a system that approaches recursive behavior. The hypothesis: if you break work into small enough pieces, prepare the right context for each piece, dispatch agents one-shot, and reflect on the results, the composed system behaves more like a recursive component than any individual guided agent could.\n\nThis is the research question at the heart of cobbler: can work breakdown + dispatch + self-reflection turn guided parts into a recursive whole?\n\nCobbler implements four autogenic self-* capabilities:\n\n1. Self-orienting (cobbler measure): the system generates new objectives rather than only selecting from predefined goals. Measure analyzes project state and proposes new tasks - it creates objectives, not just picks from a backlog.\n\n2. Self-programming (cobbler stitch): the system synthesizes new behaviors autonomously. Stitch dispatches a guided coding agent with a small, well-defined task and complete context. One-shot, no iteration. The agent synthesizes docs or code.\n\n3. Self-reflection (cobbler inspect / cobbler mend): the system evaluates its own reasoning processes and decision frameworks. Inspect and mend evaluate what was produced, examine whether the right checks exist, and dispatch agents to fix issues.\n\n4. Self-architecting (cobbler pattern): the system modifies its core architecture and integrates new functionality at runtime. Pattern proposes changes to ARCHITECTURE, PRDs, interfaces, and component organization.\n\nThe command set uses shoemaking metaphors:\n\n| Self-capability | Command | What it does |\n|----------------|---------|-------------|\n| Self-orienting | cobbler measure | Generate objectives from project state |\n| Self-programming | cobbler stitch | Dispatch guided agent to synthesize docs/code |\n| Self-reflection | cobbler inspect / mend | Evaluate output, dispatch agent to fix |\n| Self-architecting | cobbler pattern | Propose structural and design changes |\n\nAgents are plug-and-play. Cobbler defines an agent interface; any LLM backend can be swapped in. Different agents may be better at different tasks - a coding agent codes, a planning agent plans. Cobbler decides what to hand each agent.\n\nCobbler replaces prototype bash scripts (scripts/make-work.sh and scripts/do-work.sh) with a proper Go tool.\n\nSections to write:\n1. Executive Summary: cobbler is a partial recursive component and testbed for composing guided coding agents into recursive behavior. Applies autogenic systems pattern to software development. Not an agent itself - a dispatch layer that breaks work down and composes guided agents. Not a task tracker, IDE plugin, or CI system.\n2. Introduction: context (coding agents are guided components with self-programming capabilities, but waste tokens and produce inconsistent results on large tasks). Problem (guided agents alone do not achieve recursive behavior; large tasks cause iteration, token waste, and poor results). What cobbler does (tests whether work breakdown + one-shot dispatch + self-reflection can compose guided agents into recursive behavior). Introduce autogenic systems and the four self-* capabilities.\n3. Why this project: testbed for the guided-to-recursive composition question. Token efficiency through work breakdown. Plug-and-play agent swapping. Graduates prototype scripts. Fills gap between task storage (crumbs) and agent execution.\n4. Planning and Implementation: success criteria (guided agents complete tasks without iteration; composed system shows recursive properties - generates objectives, synthesizes behaviors, evaluates reasoning, modifies structure), phases table (01.0 stitch docs, 02.0 stitch code, 03.0 measure, 04.0 inspect/mend/pattern), risks table.\n5. What This Is NOT: not a coding agent. Not a planning agent. Not a recursive component yet (partial - testbed). Not a task tracker (use crumbs). Not an IDE plugin. Not a CI system. Not an interactive agent session.\n\n## Acceptance Criteria\n- [ ] All required sections per vision-format present\n- [ ] Clear that cobbler is a partial recursive component and testbed\n- [ ] Clear that coding agents are guided components\n- [ ] Research question stated: can work breakdown + dispatch + reflection compose guided agents into recursive behavior\n- [ ] Formal self-* definitions used\n- [ ] Work breakdown as token efficiency mechanism\n- [ ] Plug-and-play agent swapping described\n- [ ] Command mapping to self-* capabilities\n- [ ] Origin story: replaces prototype scripts\n- [ ] Style follows documentation-standards\n- [ ] File saved as docs/VISION.md","status":"closed","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:46:02.295666-05:00","created_by":"petardjukic","updated_at":"2026-02-05T22:36:20.471425-05:00","closed_at":"2026-02-05T20:58:29.426371-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cobbler-mq5.1","depends_on_id":"cobbler-mq5","type":"parent-child","created_at":"2026-02-05T18:46:02.297302-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-mq5.2","title":"Write ARCHITECTURE.md","description":"## Required Reading\n- docs/VISION.md (written in prior issue)\n- .claude/rules/architecture-format.md (format rule)\n- .claude/rules/documentation-standards.md (writing style)\n- .claude/rules/promt.md (Cupboard/Table design brief)\n- Crumbs docs: /Users/petardjukic/WORKSPACE/crumbs/docs/ARCHITECTURE.md (cupboard/table interfaces)\n- Crumbs PRDs: /Users/petardjukic/WORKSPACE/crumbs/docs/product-requirements/ (interface contracts)\n\n## Files to Create\n- docs/ARCHITECTURE.md\n\n## Requirements\n\nWrite ARCHITECTURE.md per architecture-format rule.\n\nCobbler is a partial recursive component that composes guided coding agents. The architecture must show how guided agents (which have self-programming but need oversight) are composed through work breakdown, one-shot dispatch, and self-reflection into a system that approaches recursive behavior.\n\nThe component hierarchy:\n- Coding agents (Claude, etc.) = guided components with self-programming. They generate code and docs but work best with human oversight. Unguided results may be poor.\n- Cobbler = partial recursive component. It does not execute work itself. It breaks work into small chunks, prepares context, dispatches guided agents one-shot, and reflects on results. The composition of these steps is what creates recursive-like behavior.\n\nAutogenic self-* capabilities and their architectural realization:\n\n1. Self-orienting (cobbler measure): generates new objectives by analyzing project state. Not selecting from a backlog - creating objectives. Replaces make-work.sh.\n\n2. Self-programming (cobbler stitch): dispatches a guided coding agent with a small, well-defined task. One-shot, no iteration. Agent receives complete context and returns result. Replaces do-work.sh.\n\n3. Self-reflection (cobbler inspect / cobbler mend): evaluates output and reasoning. Examines not just whether tests pass but whether the right tests exist. Dispatches agent to fix issues.\n\n4. Self-architecting (cobbler pattern): dispatches agent to propose changes to ARCHITECTURE, PRDs, interfaces, component organization.\n\nCommands:\n\n| Self-capability | Command | What it does |\n|----------------|---------|-------------|\n| Self-orienting | cobbler measure | Generate objectives from project state |\n| Self-programming | cobbler stitch | Dispatch guided agent one-shot |\n| Self-reflection | cobbler inspect / mend | Evaluate output, dispatch fix |\n| Self-architecting | cobbler pattern | Propose structural changes |\n\nSections to write:\n1. System Overview: cobbler is a partial recursive component that composes guided coding agents. It sits between crumbs cupboard and pluggable guided agents. The composition (work breakdown + one-shot dispatch + reflection) is what creates recursive-like behavior from guided parts. Lifecycle (ready -\u003e claimed -\u003e context gathered -\u003e prompt built -\u003e guided agent dispatched one-shot -\u003e result -\u003e quality gate -\u003e closed). Pull-based coordination.\n2. Main interfaces: Cupboard integration (import crumbs Go module, Cupboard.GetTable(name).Get/Set), Agent interface (the plug-and-play boundary; guided agents implement this; one-shot execution model), Executor interface (claim, gather context, build prompt, dispatch one-shot, evaluate, close). The agent interface abstracts over guided coding agents so different backends can be swapped in.\n3. System Components: CLI (cobra, commands: measure, stitch, inspect, mend, pattern), Config (viper), Measure (self-orienting: generates objectives from project analysis - replaces make-work.sh), Stitch/Executor (self-programming: prepares context, dispatches guided agent one-shot - replaces do-work.sh), Inspect/Mend (self-reflection: evaluates output, dispatches fix), Pattern (self-architecting: proposes structural changes), Agent (abstraction over guided coding agents; Claude impl via anthropic-sdk-go; plug-and-play), Prompt Builder (templates for one-shot dispatch - gives guided agent everything it needs without iteration), Crumbs Client (thin wrapper around crumbs Go module).\n4. Design Decisions: (a) cobbler is a partial recursive component composed from guided agents - the composition is the experiment, (b) work breakdown is how guided agents become useful without iteration - small tasks avoid the token waste and poor results of large tasks, (c) one-shot dispatch - no conversation with the agent, (d) agent interface abstracts over guided coding agents - plug-and-play, (e) prompt templates designed so guided agents can execute without needing to ask questions, (f) import crumbs as Go module, (g) shoemaking command names mapped 1:1 to autogenic self-* capabilities.\n5. Technology Choices: Go, cobra, viper, crumbs module (github.com/petar-djukic/crumbs), anthropic-sdk-go.\n6. Project Structure: cmd/cobbler/, pkg/ (agent, planner, executor, crumbs), internal/ (prompt, config, claude).\n7. Implementation Status: phase 01.0 focus is cobbler stitch --docs (self-programming with guided coding agent for documentation).\n\n## Design Decisions\n- Cobbler is a partial recursive component composed from guided agents\n- Work breakdown makes guided agents effective without iteration\n- One-shot dispatch: no agent conversation, complete context upfront\n- Agent interface abstracts over guided coding agents: plug-and-play\n- Prompt templates designed for guided agents to execute without questions\n- Cupboard via Go module import (github.com/petar-djukic/crumbs)\n- Shoemaking command names mapped 1:1 to autogenic self-* capabilities\n\n## Acceptance Criteria\n- [ ] All required sections per architecture-format present\n- [ ] Clear component hierarchy: guided coding agents composed by partial recursive cobbler\n- [ ] Autogenic self-* capabilities mapped to architecture components with formal definitions\n- [ ] One-shot dispatch model - guided agents receive complete context, no iteration\n- [ ] Work breakdown as mechanism for making guided agents effective\n- [ ] Agent interface as plug-and-play boundary over guided coding agents\n- [ ] Command set documented with self-* mapping\n- [ ] Design decisions numbered with rationale\n- [ ] Technology choices table present\n- [ ] Project structure directory tree present\n- [ ] Style follows documentation-standards\n- [ ] File saved as docs/ARCHITECTURE.md","status":"closed","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:46:21.116325-05:00","created_by":"petardjukic","updated_at":"2026-02-05T22:36:52.715874-05:00","closed_at":"2026-02-05T21:00:28.763235-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cobbler-mq5.2","depends_on_id":"cobbler-mq5","type":"parent-child","created_at":"2026-02-05T18:46:21.117113-05:00","created_by":"petardjukic"},{"issue_id":"cobbler-mq5.2","depends_on_id":"cobbler-mq5.1","type":"blocks","created_at":"2026-02-05T18:46:21.118001-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-mq5.3","title":"Write ROADMAP.yaml","description":"## Required Reading\n- docs/VISION.md (written in prior issue)\n- .claude/rules/use-case-format.md (release numbering scheme)\n\n## Files to Create\n- docs/ROADMAP.yaml\n\n## Requirements\n\nWrite ROADMAP.yaml as a YAML file defining the release schedule and use case status for cobbler.\n\nCommands use shoemaking terms mapped to autogenic self-* capabilities:\n- measure (self-orienting): assess state, propose tasks\n- stitch (self-programming): execute work via agents\n- inspect (self-reflecting): show project state\n- mend (self-reflecting): fix tests and lint\n- pattern (self-architecting): propose design changes\n\nReleases:\n- 00.0: Cross-release milestones (spans multiple releases)\n- 01.0: Core stitch (docs) - cobbler stitch --docs working end-to-end\n  - Use cases: cupboard connection, doc task execution, agent loop\n- 02.0: Core stitch (code) - cobbler stitch --code working\n  - Use cases: code task execution, quality gates (test, lint)\n- 03.0: Measure - cobbler measure working (replaces make-work.sh)\n  - Use cases: project analysis, work proposal, crumb creation\n- 04.0: Inspect, mend, and pattern - remaining self-* capabilities\n  - Use cases: project state display, test/lint fix loop, design proposals\n- 99.0: Unscheduled\n\nEach release entry should include: focus description, list of use cases with status (planned/in-progress/done), and deliverables.\n\n## Acceptance Criteria\n- [ ] YAML is valid and parseable\n- [ ] All releases listed with focus, use cases, and deliverables\n- [ ] Commands use revised names (measure, stitch, inspect, mend, pattern)\n- [ ] Release numbering matches use-case-format convention (NN.N)\n- [ ] File saved as docs/ROADMAP.yaml","status":"closed","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-05T18:46:32.340903-05:00","created_by":"petardjukic","updated_at":"2026-02-05T21:01:26.396186-05:00","closed_at":"2026-02-05T21:01:26.396186-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cobbler-mq5.3","depends_on_id":"cobbler-mq5","type":"parent-child","created_at":"2026-02-05T18:46:32.341608-05:00","created_by":"petardjukic"},{"issue_id":"cobbler-mq5.3","depends_on_id":"cobbler-mq5.1","type":"blocks","created_at":"2026-02-05T18:46:32.342535-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-n3u","title":"Cobbler PRDs","description":"PRDs that define cobbler's interfaces and operations before we write code. Covers agent interface, development loop, measure, and stitch. These PRDs define the contracts that release 01.0+ code will implement.","status":"open","priority":2,"issue_type":"epic","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:15:40.736059-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:15:40.736059-05:00"}
{"id":"cobbler-n3u.1","title":"PRD: Agent Interface","description":"## Required Reading\n- docs/ARCHITECTURE.md (Agent Interface, Executor Interface sections)\n- scripts/do-work.sh (lines 141-157, current invocation pattern)\n- scripts/make-work.sh (lines 317-331, same invocation pattern)\n\n## Files to Create\n- docs/product-requirements/prd-agent-interface.md\n\n## Requirements\n\nWrite PRD per prd-format rule. The agent interface is how cobbler invokes coding agents from Go code. Today the scripts exec the claude CLI via pipe: echo \"$prompt\" | claude --dangerously-skip-permissions -p. The PRD defines the Go interface that replaces this.\n\n## Required Sections (per prd-format)\n\n1. Problem - exec is not programmatic: no type safety, no tool registration, no response parsing, no error handling beyond exit codes. Context assembly and agent invocation are tangled in bash string concatenation.\n\n2. Goals - Type-safe Go interface for agent invocation. Pluggable providers (Claude first, others later). Tool registration and execution. Structured response handling. Token tracking per invocation.\n\n3. Requirements\n- R1: Agent interface with Run method (prompt, tools) returning Response\n- R2: Tool interface (Name, Description, Execute) for registering agent tools\n- R3: Response struct (Content, ToolCalls, TokensUsed)\n- R4: Conversation loop: send prompt, receive tool calls, execute tools, send results, repeat until agent signals done\n- R5: Claude implementation via anthropic-sdk-go\n- R6: Timeout and cancellation via context.Context\n- R7: Token usage tracking per invocation and cumulative\n- R8: Error types: agent error, tool error, timeout, rate limit\n- R9: Configuration: model selection, max tokens, temperature\n\n4. Non-Goals - Multi-provider support beyond interface definition in v1. Streaming UI. Prompt construction (covered by stitch PRD). Agent memory across invocations.\n\n5. Acceptance Criteria\n- [ ] All required sections present per prd-format\n- [ ] Interface contracts specified with Go signatures\n- [ ] Conversation loop state machine defined\n- [ ] Error types enumerated\n- [ ] Token tracking requirements specified\n- [ ] File saved as prd-agent-interface.md\n\n## Format Rule\nFollow .claude/rules/prd-format.md","status":"closed","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:15:59.56588-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:27:16.371981-05:00","closed_at":"2026-02-06T07:27:16.371981-05:00","close_reason":"Closed","dependencies":[{"issue_id":"cobbler-n3u.1","depends_on_id":"cobbler-n3u","type":"parent-child","created_at":"2026-02-06T07:15:59.567373-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-n3u.2","title":"PRD: Stitch","description":"## Required Reading\n- docs/VISION.md (inductive development, context minimization)\n- docs/ARCHITECTURE.md (Lifecycle, Executor Interface, Prompt Builder, Git Worktree Model)\n- scripts/do-work.sh (full script: pick_task lines 71-93, build_prompt lines 117-139, do_one_task lines 193-200)\n- docs/product-requirements/prd-agent-interface.md (agent contract, once written)\n\n## Files to Create\n- docs/product-requirements/prd-stitch.md\n\n## Requirements\n\nWrite PRD per prd-format rule. Stitch is how cobbler executes work via agents. Based on do-work.sh. The PRD defines the full claim-context-dispatch-evaluate-close workflow for a single task.\n\n## Required Sections (per prd-format)\n\n1. Problem - do-work.sh limitations: builds prompts via string concatenation with minimal context (just task title + description + 'read VISION and ARCHITECTURE'). No context management — every task gets the same prompt shape regardless of work type. No quality evaluation of agent output. No structured template system.\n\n2. Goals - Minimal context assembly per work type. One-shot dispatch via agent interface. Quality gates before closing. Work type routing (documentation vs coding vs operations). Template-driven prompt construction.\n\n3. Requirements\n- R1: Task picker — query cupboard for ready crumbs, select by priority and work type\n- R2: Claim/release — set crumb state to taken, release on failure\n- R3: Context assembler — assemble different context per work type (documentation: relevant docs and PRDs; coding: relevant source files, tests, PRDs; operations: config files, build output)\n- R4: Prompt builder — Go templates, substitution from crumb fields and project context\n- R5: Agent dispatch — invoke agent interface with assembled prompt and registered tools\n- R6: Git worktree management for code tasks (create branch, add worktree, merge, cleanup)\n- R7: Quality gate execution — run tests, linter, build before marking completed\n- R8: Crumb state transitions — ready to taken to completed/failed\n- R9: Token and LOC tracking per task\n- R10: Template system — templates stored as crumbs, swappable per work type\n\n4. Non-Goals - Parallel task execution in v1. Template modification during stitch. Measure integration (measure creates work; stitch executes it). Interactive agent sessions.\n\n5. Acceptance Criteria\n- [ ] All required sections present per prd-format\n- [ ] Context assembly strategy per work type defined\n- [ ] Prompt template variables and structure specified\n- [ ] Worktree lifecycle documented\n- [ ] Quality gate requirements specified\n- [ ] State transitions match crumbs prd-crumbs-interface\n- [ ] File saved as prd-stitch.md\n\n## Format Rule\nFollow .claude/rules/prd-format.md","status":"open","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:16:19.957043-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:16:19.957043-05:00","dependencies":[{"issue_id":"cobbler-n3u.2","depends_on_id":"cobbler-n3u","type":"parent-child","created_at":"2026-02-06T07:16:19.95819-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-n3u.3","title":"PRD: Measure","description":"## Required Reading\n- docs/VISION.md (inductive development, context management, Guided and Recursive)\n- docs/ARCHITECTURE.md (System Components — Measure, Operations as Crumbs)\n- scripts/make-work.sh (full script: build_prompt lines 209-315, import_issues lines 121-207, get_existing_issues lines 104-118)\n- docs/product-requirements/prd-agent-interface.md (agent contract, once written)\n\n## Files to Create\n- docs/product-requirements/prd-measure.md\n\n## Requirements\n\nWrite PRD per prd-format rule. Measure is how cobbler assesses project state and proposes new work. Based on make-work.sh. The PRD defines how cobbler reads project state, assembles context for a planning agent, invokes the agent to propose work, and writes proposals back to the cupboard as new crumbs.\n\n## Required Sections (per prd-format)\n\n1. Problem - make-work.sh limitations: builds a monolithic prompt by concatenating all existing issues, project docs, and rules into one string. No structured project state reader. Outputs proposed issues as a JSON file that gets imported via a separate bash function. No direct cupboard write-back. The planning context is everything-at-once rather than curated.\n\n2. Goals - Structured project state analysis. Curated context for the planning agent (not everything-at-once). Direct cupboard write-back for proposed crumbs. Work type property set on created crumbs. Roadmap-aware task proposal.\n\n3. Requirements\n- R1: Project state reader — read VISION, ARCHITECTURE, roadmap, and cupboard state (existing crumbs, their status, work types)\n- R2: Context assembly for planning agent — curate what the planning agent sees: current release focus, incomplete use cases, existing work, project stats (LOC, doc words)\n- R3: Agent dispatch — invoke agent interface with planning context\n- R4: Proposal format — agent outputs proposed crumbs with title, description, work type, and priority\n- R5: Cupboard write-back — write approved proposals directly to cupboard via Table.Set, no JSON file intermediate\n- R6: Work type assignment — each proposed crumb gets a type property (planning, documentation, coding, operations)\n- R7: Roadmap alignment — proposals map to use cases in the roadmap; unassigned work goes to release 99.0\n- R8: Review mode — measure can output proposals for human review before writing to cupboard\n- R9: Issue limit — configurable cap on number of proposals per invocation\n\n4. Non-Goals - Autonomous approval (human reviews in v1). Multi-project analysis. Modifying roadmap or VISION (that is pattern). Running stitch after measure (that is the development loop).\n\n5. Acceptance Criteria\n- [ ] All required sections present per prd-format\n- [ ] Project state reader inputs specified\n- [ ] Context assembly strategy for planning agent defined\n- [ ] Proposal format and work type assignment specified\n- [ ] Cupboard write-back vs review mode documented\n- [ ] File saved as prd-measure.md\n\n## Format Rule\nFollow .claude/rules/prd-format.md","status":"open","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:16:38.889597-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:16:38.889597-05:00","dependencies":[{"issue_id":"cobbler-n3u.3","depends_on_id":"cobbler-n3u","type":"parent-child","created_at":"2026-02-06T07:16:38.89139-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-n3u.4","title":"PRD: Development Loop","description":"## Required Reading\n- docs/VISION.md (inductive development, Guided and Recursive, path dependency)\n- docs/ARCHITECTURE.md (Lifecycle, Operations as Crumbs, System Components)\n- scripts/do-work.sh (main loop lines 217-251, cycle management)\n- scripts/make-work.sh (integration point — called when queue is empty)\n- docs/product-requirements/prd-stitch.md (once written)\n- docs/product-requirements/prd-measure.md (once written)\n\n## Files to Create\n- docs/product-requirements/prd-development-loop.md\n\n## Requirements\n\nWrite PRD per prd-format rule. The development loop is the full cycle: measure, stitch, inspect, mend, pattern. do-work.sh partially implements this (pick task, execute, close, call make-work when queue is empty, repeat for N cycles). The PRD defines how the five operations compose into an iterative loop that manages the inductive development path.\n\n## Required Sections (per prd-format)\n\n1. Problem - do-work.sh implements a basic loop: drain the task queue, call make-work when empty, repeat. But the loop has no evaluation (inspect), no repair (mend), no design feedback (pattern). It cannot detect when the path is going wrong (code tangling) or adjust its approach. The five operations exist independently in the architecture but have no defined composition.\n\n2. Goals - Single iterative loop composing all five operations. Path management: detect when the codebase is degrading and intervene (break down refactors, propose design changes). Configurable cycles and operation ordering. Failure recovery. Metrics per cycle (tokens, LOC delta, task count).\n\n3. Requirements\n- R1: Loop state machine — states: idle, measuring, stitching, inspecting, mending, patterning. Transitions between operations.\n- R2: Default operation order — measure (if queue empty), stitch (drain queue), inspect (after stitch batch), mend (if inspect finds issues), pattern (periodically or on structural problems)\n- R3: Cycle management — configurable number of measure-stitch cycles (like do-work.sh --cycles)\n- R4: Queue empty handling — invoke measure to propose new work, then continue stitching\n- R5: Failure recovery — if stitch fails, mark crumb failed, continue to next task. If repeated failures, invoke inspect.\n- R6: Path health — after each stitch batch, check code quality indicators (test pass rate, lint issues, LOC growth rate). If degrading, invoke pattern.\n- R7: Operation dispatch — each operation reads its definition from the cupboard (operation crumbs). Initially fixed definitions; template system enables modification.\n- R8: Metrics per cycle — tokens used, tasks completed/failed, LOC delta (production and test), doc words delta\n- R9: Human touchpoints — report to human after each cycle. Surface decisions that need judgment. Continue or stop based on human input.\n\n4. Non-Goals - Recursive operation modification in v1 (pattern can propose changes; human approves). Parallel task execution. Autonomous multi-cycle runs without human check-in. DAG-based operation ordering.\n\n5. Acceptance Criteria\n- [ ] All required sections present per prd-format\n- [ ] Loop state machine defined with transitions\n- [ ] Default operation order and cycle management specified\n- [ ] Failure recovery strategy documented\n- [ ] Path health indicators identified\n- [ ] Metrics per cycle specified\n- [ ] Human touchpoints defined\n- [ ] File saved as prd-development-loop.md\n\n## Dependencies\n- cobbler-n3u.1 (PRD: Agent Interface) — loop dispatches operations that use agents\n- cobbler-n3u.2 (PRD: Stitch) — stitch is the core operation in the loop\n- cobbler-n3u.3 (PRD: Measure) — measure creates work for stitch\n\n## Format Rule\nFollow .claude/rules/prd-format.md","status":"open","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:17:03.247554-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:17:03.247554-05:00","dependencies":[{"issue_id":"cobbler-n3u.4","depends_on_id":"cobbler-n3u","type":"parent-child","created_at":"2026-02-06T07:17:03.248601-05:00","created_by":"petardjukic"}]}
{"id":"cobbler-q42","title":"Benchmark runner script","description":"## Required Reading\n- scripts/do-work.sh (prototype stitch: task picking, worktree, Claude invocation)\n- benchmarks/hello-world/benchmark.yaml (fixture metadata and pass criteria)\n- docs/use-cases/rel01.0-uc004-benchmark-hello-world.md (use case this runner validates)\n\n## Files to Create/Modify\n- scripts/run-benchmark.sh (create) - Runs a benchmark fixture end-to-end, reports pass/fail\n\n## Requirements\n- Takes a benchmark directory as argument: ./scripts/run-benchmark.sh benchmarks/hello-world\n- Reads benchmark.yaml for: name, language, expected files, pass criteria\n- Creates a temp working directory, copies the fixture VISION.md into it\n- Invokes Claude (via claude CLI, same pattern as do-work.sh) with a prompt built from the fixture spec\n- After Claude completes, checks pass criteria: expected files exist, go build succeeds, output matches expected string\n- Reports pass/fail with summary (files created, build status, output check)\n- Cleans up temp directory on exit\n\n## Design Decisions\n- Uses the prototype Claude invocation pattern (echo prompt | claude --dangerously-skip-permissions -p) since cobbler stitch does not exist yet\n- Reads benchmark.yaml with yq or a simple parser (avoid Python dependency)\n- Pass criteria checking is sequential: file exists, then build, then output\n- Exit code 0 on pass, 1 on fail\n\n## Acceptance Criteria\n- [ ] run-benchmark.sh runs against benchmarks/hello-world/ and reports pass/fail\n- [ ] Pass criteria from benchmark.yaml are checked\n- [ ] Temp directory is cleaned up on success and failure\n- [ ] Script is self-contained (no cobbler binary needed)","status":"open","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:25:16.286743-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:25:16.286743-05:00","labels":["code"]}
{"id":"cobbler-qss","title":"Bootstrap cobbler Go module and CLI","description":"## Required Reading\n- docs/ARCHITECTURE.md § Project Structure, § Cupboard Integration\n- docs/road-map.yaml (release 01.0 deliverables: cmd/cobbler CLI entry point with stitch subcommand)\n- /Users/petardjukic/WORKSPACE/crumbs/go.mod (crumbs module path for import)\n\n## Files to Create/Modify\n- go.mod (create) - module github.com/petar-djukic/cobbler, require crumbs\n- go.sum (create) - generated by go mod tidy\n- cmd/cobbler/main.go (create) - Cobra CLI root command, version flag\n- cmd/cobbler/stitch.go (create) - stitch subcommand stub (flags parsed, prints not implemented)\n- cmd/cobbler/measure.go (create) - measure subcommand stub\n\n## Requirements\n- Go module with correct module path (github.com/petar-djukic/cobbler)\n- Import crumbs module via go.mod replace directive (local path to ../crumbs)\n- Cobra CLI with root command (cobbler), version subcommand, help text\n- stitch subcommand: accepts --type flag (docs/code), prints stub message\n- measure subcommand: prints stub message\n- go build ./cmd/cobbler produces working binary\n\n## Design Decisions\n- Use Cobra for CLI (standard Go CLI library, matches crumbs pattern)\n- Use go.mod replace directive for local crumbs development (not published yet)\n- Stubs print clear not implemented messages with the subcommand name\n- Follow Go project layout: cmd/ for entry points, internal/ for implementation, pkg/ for shared types\n\n## Acceptance Criteria\n- [ ] go build ./cmd/cobbler succeeds\n- [ ] cobbler --help shows available commands\n- [ ] cobbler stitch --help shows stitch flags\n- [ ] cobbler measure --help shows measure description\n- [ ] go mod tidy runs clean","status":"open","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:24:52.0707-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:24:52.0707-05:00","labels":["code"]}
{"id":"cobbler-rbu","title":"PRD: Observability and tracing","description":"## Required Reading\n- docs/VISION.md (inductive development, path dependency, context management)\n- docs/ARCHITECTURE.md (operations lifecycle, agent interface, crumbs trails)\n- docs/road-map.yaml (release schedule)\n\n## Files to Create/Modify\n- docs/product-requirements/prd-observability.md (create)\n\n## Required Sections (per prd-format rule)\n\n1. Problem - Cobbler runs iterative loops (measure → stitch → inspect → mend → pattern) dispatching agents one-shot. Without tracing, we cannot see which steps succeeded, which failed, where context was insufficient, or how the inductive path evolved. We need structured observability to understand and improve the system.\n\n2. Goals - Record every operation invocation as a span with inputs, outputs, duration, and outcome. Enable visualization of the inductive path (sequence of steps taken, branches, backtracks). Support comparison of different context strategies (templates) via trail data.\n\n3. Requirements - OpenTelemetry integration for span-based tracing. Span hierarchy: loop \u003e operation \u003e agent invocation \u003e tool calls. Attributes on spans: operation type, crumb ID, context size (tokens), outcome (success/failure/partial), duration. Export to OTLP endpoint (configurable). Local fallback: JSON trace file when no collector is running. GUI or dashboard for visualizing past runs: timeline of operations, success/failure coloring, drill-down into individual spans. Trail integration: link spans to crumbs trails so we can correlate tracing data with the work items and context strategies used.\n\n4. Non-Goals - Not building a custom tracing backend (use existing OTLP collectors). Not real-time monitoring or alerting. Not replacing crumbs trails (tracing complements trails, does not replace them).\n\n5. Acceptance Criteria - Each cobbler operation emits an OpenTelemetry span. Spans export to a configurable OTLP endpoint. A local JSON trace file is written when no collector is available. A visualization tool (Jaeger, Grafana Tempo, or custom lightweight UI) can render the operation timeline. Documentation describes how to set up and use observability.\n\n## Release\n99.0 (unscheduled)\n\n## Acceptance Criteria\n- [ ] All required PRD sections present\n- [ ] File saved as prd-observability.md\n- [ ] Requirements are numbered and specific\n- [ ] Tracing spans cover the full operation hierarchy\n- [ ] GUI/visualization approach specified","status":"open","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:20:42.500764-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:20:42.500764-05:00","labels":["documentation"]}
{"id":"cobbler-trj","title":"Use case: Hello World benchmark","description":"## Required Reading\n- docs/VISION.md (inductive development, context management, what cobbler does)\n- docs/ARCHITECTURE.md (lifecycle, stitch workflow, agent interface)\n- docs/road-map.yaml (release 01.0 use cases)\n- .claude/rules/use-case-format.md (use case format rule)\n\n## Files to Create/Modify\n- docs/use-cases/rel01.0-uc004-benchmark-hello-world.md (create)\n\n## Required Sections (per use-case-format rule)\n1. Summary - Given a directory with a spec doc for a hello world Go CLI, cobbler reads the spec, creates a task, dispatches an agent, agent produces a working main.go\n2. Actor and trigger - Developer invokes cobbler stitch against a benchmark fixture directory\n3. Flow - Numbered steps: read spec, create task in cupboard, build prompt from template, dispatch agent, agent writes code, evaluate result (go build, output check)\n4. Architecture touchpoints - Cupboard (task storage), stitch executor, agent interface, prompt templates, quality gates\n5. Success/demo criteria - go build passes, binary prints Hello World, benchmark runner reports pass\n6. Out of scope - Multiple-file apps, test generation, refactoring loops\n\n## Acceptance Criteria\n- [ ] All required use case sections present\n- [ ] File saved at docs/use-cases/rel01.0-uc004-benchmark-hello-world.md\n- [ ] Flow maps to real architecture components\n- [ ] Success criteria are observable and checkable","status":"open","priority":2,"issue_type":"task","owner":"petar.djukic@gmail.com","created_at":"2026-02-06T07:24:28.205291-05:00","created_by":"petardjukic","updated_at":"2026-02-06T07:24:28.205291-05:00","labels":["documentation"]}
